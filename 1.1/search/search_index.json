{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":"<p>Observes Semantic Versioning standard and Keep a Changelog convention.</p>"},{"location":"changelog/#110-02-06-23","title":"[1.1.0] - 02-06-23","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>DateRangePicker component PR #72</li> <li>Slideshow component PR #72</li> </ul>"},{"location":"changelog/#102-1-31-23","title":"1.0.2 - 1-31-23","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Forms for tables with datetime FPKs would return an incorrect datetime format, causing inserts to fail (#62) PR #64</li> </ul>"},{"location":"changelog/#101-1-26-23","title":"1.0.1 - 1-26-23","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Attributes with \"null\" or \"NULL\" default values would incorrectly get marked as required inputs in forms (#60) PR #61</li> </ul>"},{"location":"changelog/#100-12-30-22","title":"1.0.0 - 12-30-22","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Kubernetes docs PR #50</li> <li>Antd Table component PR #53, #54</li> <li>Dynamic form component PR #55</li> </ul>"},{"location":"changelog/#011-04-01-22","title":"0.1.1 - 04-01-22","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for hosting sci-viz under a subdirectory PR #44</li> </ul>"},{"location":"changelog/#010-03-18-22","title":"0.1.0 - 03-18-22","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>pharus As submodule (#17) PR #33</li> <li>Components PR #33:<ul> <li><code>table</code></li> <li><code>markdown</code></li> <li><code>metadata</code></li> <li><code>plot:plotly:stored_json</code></li> <li><code>file:image:attach</code></li> </ul> </li> <li>Components PR #41:<ul> <li><code>radiobuttons</code></li> <li><code>dropdown-query</code></li> <li><code>dropdown-static</code></li> </ul> </li> <li>Grid system PR #33</li> <li>Dynamic grid system (#23) PR #33</li> <li>Database Login PR (#9) #33</li> <li>Basic GHA for repo PR (#26) #33</li> <li>Hotreloading based off of spec sheet (#24) PR #33</li> <li>Initial framework for jest testing (#27) PR #33</li> <li>loginless mode PR #41</li> </ul>"},{"location":"citation/","title":"Citation","text":"<ul> <li>If your work uses DataJoint Sci-Viz, please cite the following Research Resource Identifier (RRID) and manuscript.</li> </ul> <ul> <li>DataJoint (RRID:SCR_014543) - DataJoint Sci-Viz (version <code>&lt;Enter version number&gt;</code>)</li> </ul> <ul> <li>Yatsenko D, Nguyen T, Shen S, Gunalan K, Turner CA, Guzman R, Sasaki M, Sitonic D, Reimer J, Walker EY, Tolias AS. DataJoint Elements: Data Workflows for Neurophysiology. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.03.30.437358</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>If you have not done so already, please install the following dependencies:</p> <ul> <li>Docker</li> <li>Docker Compose</li> </ul>"},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Before running the application through docker, make sure to run the command:</p> <pre><code>python frontend_gen.py\n</code></pre> <p>This will compile the necessary typescript files for the frontend and the necessary python files for the backend. you can also run this at any time during a dev deployment to hot-load the frontend, however this is not always guaranteed to work as some changes may require the entire react server to restart. Anything related to the back end api is not hot-loadable but for example the component locations and sizes can be modified and hot-loaded.</p> <p>Also see the .env section to set up your environment variables.</p>"},{"location":"getting_started/#running-the-application","title":"Running the application","text":"<p>To start the application in dev mode, use the command:</p> <pre><code>PY_VER=3.8 IMAGE=djbase DISTRO=alpine PHARUS_VERSION=$(cat pharus/pharus/version.py | tail -1 | awk -F\\' '{print $2}') HOST_UID=$(id -u) docker-compose up --build\n</code></pre> <p>To run the application in Production mode, use the command:</p> <pre><code>docker-compose -f docker-compose-deploy.yaml up --build\n</code></pre> <p>To stop the application, use the same command as before but with <code>down</code> in place of <code>up --build</code></p>"},{"location":"concepts/components/","title":"Components","text":"<p>All components need minimally these fields:</p> <ul> <li><code>type:</code> indicates the type of component you are trying to generate</li> <li><code>route:</code> the backend route for the rest api query, must start with a <code>/</code><ul> <li>Note: the markdown component does not require a route</li> </ul> </li> <li><code>x:</code> x position on the grid starting at 0</li> <li><code>y:</code> y position on the grid starting at 0</li> <li><code>height:</code> the amount of grid squares tall a component can be, minimum 1</li> <li><code>width:</code> the amount of grid square wide a compoentnt can be, minimum 1</li> </ul>"},{"location":"concepts/components/#table-component","title":"Table component","text":"<p><code>type:</code> table</p> <p>The Table component takes a two additional fields:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query</li> <li><code>dj_query:</code> the datajoint query for for the table data</li> </ul> <p>If setup correctly the component will render the result of the query in a table that supports paging, sorting, and filtering.</p>"},{"location":"concepts/components/#adding-color-to-your-tables-using-projections","title":"Adding color to your tables using projections","text":"<pre><code>def dj_query(vms):\n    TableA, TableB = (vms['test_group1_simple'].TableA, vms['test_group1_simple'].TableB)\n    return ((TableA * TableB).proj(...,\n                                   _sciviz_font='IF(a_name = \"Raphael\", \"rgb(255, 0, 0)\", NULL)',\n                                   _sciviz_background='IF(a_name = \"Raphael\", \"rgba(50, 255, 0, 0.16)\", NULL)',)\n                                  ), dict(order_by='b_number')\n</code></pre> <p>This is an example of a table query that has a projection that applys a text color as well as a background color. It does so through the use of 2 protected column names:</p> <ul> <li><code>_sciviz_font</code> for the font color</li> <li><code>_sciviz_background</code> for the background color   these two fields will accept any color format that css does.</li> </ul> <p>In the example we do a join of two tables and then do a projection where we create 2 new columns with the protected names and if a condition is met we set their field to a css-compatable color else we have it be <code>NULL</code>. In the example above we use rgb when we do not need transparency and rgba when we do. here is a good tool for picking css colors.</p>"},{"location":"concepts/components/#markdown-component","title":"Markdown component","text":"<p><code>type:</code> markdown</p> <p>The Markdown component takes one additional field:</p> <ul> <li><code>text: |</code><ul> <li>underneath the <code>|</code> operator you can place any markdown text block that you want.</li> </ul> </li> </ul>"},{"location":"concepts/components/#plot-component-from-stored-plotly-json","title":"Plot component from stored Plotly JSON","text":"<p><code>type:</code> plot:plotly:stored_json</p> <p>The Plot component takes two additional arguments:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query</li> <li><code>dj_query:</code> the datajoint query for for the table data.</li> </ul> <p>The Plot component also takes one optional argument:</p> <ul> <li><code>channels:</code> an array of channels to listen to for additional restrictions from other components (slider, dropdown, ect.)</li> </ul> <p>Additionally for the plot to render properly the result of your query must be a single entry with one element that is a plotly JSON. An easy way to do this is to set the <code>fetch_args=[]</code> in your <code>dj_query</code> to be only the column that contains a plotly JSON and additionaly set your restriction to be the index of the plot you are looking for</p>"},{"location":"concepts/components/#metadata-component","title":"Metadata component","text":"<p><code>type:</code> metadata</p> <p>The Metadata component takes two additional arguments:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query</li> <li><code>dj_query:</code> the datajoint query for for the table data.</li> </ul> <p>Additionally the metadata component only takes a single row from a table as its input so the <code>dj_query</code> and <code>restriction</code> need to be properly set to produce a single record. This component is not very useful by itself but when combined with other components as part of a template in a <code>Dynamic grid</code> it can provide useful information on what the other components are showing.</p>"},{"location":"concepts/components/#image-component","title":"Image component","text":"<p><code>type:</code> file:image:attach</p> <p>The Image component takes two additional arguments:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query</li> <li><code>dj_query:</code> the datajoint query for for the table data.</li> </ul> <p>Additionally the image that you want to display needs to be stored as a datajoint attach attribute type and your query should produce only one record with one column which is the column where the image is stored.</p>"},{"location":"concepts/components/#form-component","title":"Form component","text":"<p><code>type:</code> form</p> <p>The Form component takes 1 additional argument:</p> <ul> <li><code>tables:</code> the list of tables in \"<code>schema.table</code>\" format to insert into<ul> <li>Table names can be templated, either fully or partially, using the <code>'{keyword}'</code> format. This keyword can then be assigned a value by an emitter component as a query parameter.</li> </ul> </li> </ul> <p>The Form can also take 2 optional arguments:</p> <ul> <li> <p><code>map:</code> a mapping to change the displayed names of the fields in the form</p> <p>A map takes a list of 3 arguments:</p> <ul> <li><code>type:</code> attribute | table</li> <li><code>input:</code> the new name of the field</li> <li><code>destination:</code> the field to be renamed</li> </ul> <p>A map entry with a <code>table</code> type can also take 1 optional argument:</p> <ul> <li><code>map:</code> a nested mapping of the same structure to change the displayed names of the table's primary key attributes</li> </ul> </li> </ul> <ul> <li><code>channels:</code> an array of channels to listen to for templated table name values.</li> </ul>"},{"location":"concepts/components/#slider-component","title":"Slider component","text":"<p>The Slider is a component that takes a datajoint query and creates a slider based off the payload that the query returns. It turns each record into an index on the slider and also emits the currently selected record on its channel as a restriction to other components.</p> <p><code>type:</code> slider</p> <p>The Slider component takes three additional arguments:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query.</li> <li><code>dj_query:</code> the datajoint query for for the table data.</li> <li><code>channel:</code> the name of the channel that the slider outputs its restriction on.</li> </ul> <p>The Slider component also takes one optional argument:</p> <ul> <li><code>channels:</code> an array of channels to listen to for restricting its own query.</li> </ul>"},{"location":"concepts/components/#radiobuttondropdown-static-component","title":"Radiobutton/Dropdown-static component","text":"<p>Similar to the Slider, the Radiobutton and Dropdown-static components are components that supply a selected restriction on a channel to a component that can accept them.</p> <p><code>type:</code> radiobuttons | dropdown-static</p> <p>The Radiobutton/Dropdown-static components take two additional arguments:</p> <ul> <li><code>channel:</code> the name of the channel that the Radiobutton/dropdown-static outputs its restriction on.</li> <li> <p><code>content:</code> dictionary of key value pairs, the key is what text is shown to the user while the value is the actual restriction.</p> <ul> <li>Example:</li> </ul> <p><code>content:   mouse 0: 'mouse_id=0'   mouse 1: 'mouse_id=1'   mouse 2: 'mouse_id=2'</code></p> </li> </ul>"},{"location":"concepts/components/#dropdown-query-component","title":"Dropdown-query component","text":"<p>The Dropdown-query component is the same as the slider component except it only expects a result with one column.</p> <p><code>type:</code> dropdown-query</p> <p>The Dropdown-query component takes three additional arguments:</p> <ul> <li><code>restriction:</code> the restriction for the datajoint query.</li> <li><code>dj_query:</code> the datajoint query for for the table data.</li> <li><code>channel:</code> the name of the channel that the slider outputs its restriction on.</li> </ul>"},{"location":"concepts/dev_instructions/","title":"Developer Instructions","text":"<p>There are a couple issues to address if you are collaborating on this project</p> <ul> <li>Contributors will have have to point the submodule to their own fork of pharus if they need to edit pharus to support new features for sci-viz.</li> <li>That change to pharus would need to be pr'd and then merged into pharus before we can pr and merge their change to sci-viz as we probably dont want unreviewed code linked to sci-viz nor do we want the submodule pointing to their fork of pharus.</li> </ul>"},{"location":"concepts/dev_instructions/#env","title":".env","text":"<p>for running frontend_gen.py you need this variable in your .env file</p> <pre><code>DJSCIVIZ_SPEC_PATH=test/test_spec.yaml\n</code></pre>"},{"location":"concepts/grids/","title":"Grids","text":"<p>Sci-Viz produces custom visualizations by putting <code>grids</code> on <code>pages</code> and then filling them with visualization <code>components</code>. Currently there are two types of grids Fixed and Dynamic</p>"},{"location":"concepts/grids/#fixed-grid","title":"Fixed grid","text":"<p>A fixed grid requires all components to explicitly give their position and size on the grid.</p> <p>A fixed <code>grid</code> takes four arguments:</p> <ul> <li><code>type:</code> indicates the type of grid, in this case <code>type: fixed</code></li> <li><code>columns:</code> the number of columns that the grid will have</li> <li><code>row_height:</code> the height of each row in pixels</li> <li><code>components:</code> a yaml dictionary of components to be spawned in the grid</li> </ul>"},{"location":"concepts/grids/#dynamic-grid","title":"Dynamic grid","text":"<p>A dynamic grid takes a datajoint query and then uses each record and applies that record as a restriction to a template of components. It then spawns a single or group of components for each record of that parent query but the components query is restricted by the entire record that has been passed in from the parent query.</p> <p>An example of this would be as follows:</p> <ul> <li>You have one table that represents all identifying data of a subject, lets use Mouse as an example for the subject and the table name</li> <li>You also have a table that contains a single plot per Mouse primary key, lets call this table MousePlots</li> <li>You have no idea how many plots are in MousePlots but you want to display a live view of all of them</li> <li>What you can do is create a dynamic grid with the parent query being for the Mouse table and a plot component with a query for the MousePlot table. This will produce all of the plots that are available without knowing how many there are in the database.</li> </ul> <p>A dynamic <code>grid</code> takes seven arguments:</p> <ul> <li><code>type:</code> indicates the type of grid, in this case <code>type: fixed</code></li> <li><code>columns:</code> the number of columns that the grid will have</li> <li><code>row_height:</code> the height of each row in pixels</li> <li><code>restriction:</code> a restriction for the datajoint query</li> <li><code>dj_query:</code> the parent datajoint query that will provide the restriction records</li> <li><code>route:</code> backend api route for the parent query</li> <li><code>component_templates:</code> a yaml dictionary of components that serve as a template</li> </ul> <p>Additionally any components in the dynamic grid do not need <code>x</code>, <code>y</code> , <code>height</code>, and <code>width</code> fields.</p> <p>Currently only the <code>metadata</code> and <code>plot</code> components are supported in dynamic mode.</p>"},{"location":"concepts/spec_sheet/","title":"Dynamic Spec Sheet","text":"<p>Sci-Viz is used to build visualization dashboards, this is done through a single spec sheet. An example spec sheet is included named <code>example_visualization_spec.yaml</code></p> <p>Important notes about restrictions in the spec sheet:</p> <ul> <li>Page names under pages must have a unique name without spaces</li> <li>Page routes must be unique</li> <li>Grid names under grids must be unique without spaces</li> <li>Component names under components must be unique but can have spaces</li> <li>The routes of individual components must be unique</li> <li>Routes must start with a <code>/</code></li> <li>Every query needs a restriction, below is the default one.<ul> <li><code>python       def restriction(**kwargs):           return dict(**kwargs)</code></li> </ul> </li> <li>Overlapping components at the same (x, y) does not work, the grid system will not allow overlapping components it will wrap them horizontally if there is enough space or bump them down to the next row.</li> </ul> <p>If the website does not work after running the frontend generation script check this list to make sure that spec sheet is constructed properly, in the future we may include a script that lints the spec sheet for you. see issue #20</p>"}]}